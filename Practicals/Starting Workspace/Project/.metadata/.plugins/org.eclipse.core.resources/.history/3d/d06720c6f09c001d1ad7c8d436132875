//Lesson 37
package com.virtualpairprogrammers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.Optional;

import scala.Tuple2;

public class Lesson37 {
	
	public static void main(String[] args) {

	
		//Lesson 37 Introducing the Requirements
/* We will be building a practical example of using Spark that would be like what we would use Spark for in real life! THis exercise is based on a routine the instructor does.
 * Good chance to practice everything that we learned.
 * So, we need to get a feel for which courses are popular and which are not. We use that data for things like calculating royalty payments. The most important raw data 
 * is very simple, just two columns. We will call it viewData. It is a log of viewings. So at some point in time, user ID number 14 has watched a chapter on a course. In this case
 * It is chapter ID 96. Every chapter in the system has a unique identifier. The data is clean so no worries. A bit later on, same user watched chapter ID 97. Later on a different user this time,
 * user ID number 13 also watched chapter 96. But then (this is important) the same user watches the same chapter again and again for a total of three times (three entreis). Note that
 * we do NOT want to count those three viewings as speareate viewings, we just want to count that this user watched chapter 96 ONCE.
 * 
 * viewData
 * userId | chapterId
 * 14	  | 96
 * 14	  | 97
 * 13	  | 96
 * 13	  | 96
 * 13	  | 96
 */
	
		System.setProperty("hadoop.home.dir", "c:/hadoop"); 
		Logger.getLogger("org.apache").setLevel(Level.WARN); 
		
		SparkConf conf = new SparkConf().setAppName("startingSpark").setMaster("local[*]"); 
		JavaSparkContext sc = new JavaSparkContext(conf);
		
		List<Tuple2<Integer, Integer>> visitsRaw = new ArrayList<>();
		visitsRaw.add(new Tuple2<>(4, 18));
		visitsRaw.add(new Tuple2<>(6, 4));
		visitsRaw.add(new Tuple2<>(10, 9));
		
		List<Tuple2<Integer, String>> usersRaw = new ArrayList<>();
		usersRaw.add(new Tuple2<> (1, "John"));
		usersRaw.add(new Tuple2<> (2, "Bob"));
		usersRaw.add(new Tuple2<> (3, "Alan"));
		usersRaw.add(new Tuple2<> (4, "Doris"));
		usersRaw.add(new Tuple2<> (5, "Marybelle"));
		usersRaw.add(new Tuple2<> (6, "Raquel"));
		
		JavaPairRDD<Integer, Integer> visits = sc.parallelizePairs(visitsRaw);
		JavaPairRDD<Integer, String> users = sc.parallelizePairs(usersRaw);
		
		JavaPairRDD<Integer, Tuple2<Optional<Integer>, Optional<String>>> joinedRdd = visits.fullOuterJoin(users);
		JavaPairRDD<Integer, Tuple2<Integer, String>> joinedRdd3 = visits.join(users);
		JavaPairRDD<Tuple2<Integer, Integer>, Tuple2<Integer, String>> joinedRdd2 = visits.cartesian(users);
		
		JavaPairRDD<Integer, Tuple2<Optional<Integer>, String>>anotherJoinedRdd = visits.rightOuterJoin(users);



	
		sc.close();
	
	}
	
}
