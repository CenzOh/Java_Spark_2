//Lesson 52
package com.virtualpairprogrammers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.Optional;
import org.spark_project.guava.collect.Iterables;

import scala.Tuple2;

public class Lesson52 {
	
	public static void main(String[] args) {

	
		//Lesson 52 Dealing with Key Screws
/* THis is a problem common in SPark. WE have a job and lets say it takes half an hour to run. But we want to get it running in 10 mins. Maybe we invest in expanding cluster size. Paying
 * for expensive instances and doesnt improve performance. Likely reason, we have an issue with all data ending on just one single node or a small num of nodes (like the last exercise).
 * Join operations work on keys and they are wide transformation recall that the data will be shuffled thats why its a wide transformation. If we dont have a wide spread of keys we can
 * end up with massive join RDDs residing on one node. Can run into out of memory exceptions. Doing work after the join will be harder and take longer.
 * 
 * How to avoid this? FIrst suggestion, rework scripts so the wide transformations occur LATER. Think of group bys and joins working on SMALL subset of data that can run quick.
 * If not possible? Resort to salting our keys. It is a simple hack but makes our scripts more complicated. THis is a last resort method. 
 * 
 */
	
		System.setProperty("hadoop.home.dir", "c:/hadoop"); 
		Logger.getLogger("org.apache").setLevel(Level.WARN); 
		
		SparkConf conf = new SparkConf().setAppName("startingSpark").setMaster("local[*]"); 
		JavaSparkContext sc = new JavaSparkContext(conf);
		
	//Q: How will initialRdd be partitioned?
	//A: 64mb blocks (at time of recording) so about 6 partitions
		JavaRDD<String> initialRdd = sc.textFile("src/main/resources/bigLog.txt");	
	//key: log level
	//value: date
		System.out.println("Initial RDD Partition SIze: " + initialRdd.getNumPartitions()); //outputs num of partitions spark determined for RDD
		
		JavaPairRDD<String, String> warningsAgainstDate = initialRdd.mapToPair( inputLine -> {
			String[] cols = inputLine.split(":"); //remember this is a narrow transformation, NO shuffling
			String level = cols[0];
			String date = cols[1];
			return new Tuple2<>(level, date);
		});
		
		System.out.println("After narrow transformation we have " + warningsAgainstDate.getNumPartitions() + " parts");
		//output num of partitions AFTER transformation, num should be same, no repartitioning going on.
		
		//Now we are going to do a "wide" transformation
		JavaPairRDD<String, Iterable<String>> results = warningsAgainstDate.groupByKey(); //expensive operation with lots of shuffling
		System.out.println(results.getNumPartitions() + " partitions after the wide transformation");
		//output num of partitions after wide transformation. num doesnt change again its just that most partitions will be empty
		
		results.foreach(it -> System.out.println("key " + it._1 + " has " + Iterables.size(it._2)+ " elements")); //loop through each key and output elements in resulting value
		
		Scanner scanner = new Scanner(System.in);
		scanner.nextLine();
		

		sc.close();
	
	}
	
}
